type _Schema_
@fulltext(
    name: "userSearch"
    language: en
    algorithm: rank
    include: [{ entity: "User", fields: [{ name: "address" }, {name: "createdAt"}] }]
  )
@fulltext(
    name: "listingSearch"
    language: en
    algorithm: rank
    include: [{ entity: "MarketItem", fields: [{ name: "user" }, { name: "date" }, { name: "collection_address" }, { name: "token_id" }] }]
  )
@fulltext(
    name: "swapSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Swap", fields: [{ name: "buyer" }, { name: "type" }, { name: "date" }, { name: "value" }, { name: "item" }] }]
  )
@fulltext(
    name: "offerSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Offer", fields: [{ name: "offerer" }, { name: "type" }, { name: "date" }, { name: "item" }, { name: "isSpecific" }, { name: "token" }, { name: "valid" }] }]
  )
  @fulltext(
    name: "bidSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Bid", fields: [{ name: "bidder" }, { name: "type" }, { name: "date" }, { name: "item" }, { name: "value" }, { name: "isSpecific" }, { name: "valid" }] }]
  )
  @fulltext(
    name: "tradeSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Trade", fields: [{ name: "trader" }, { name: "type" }, { name: "date" }, { name: "item" }, { name: "isSpecific" }, { name: "valid" },] }]
  )
  @fulltext(
    name: "nftSearch"
    language: en
    algorithm: rank
    include: [{ entity: "NFT", fields: [{ name: "contract_type" }, { name: "token_address" }, { name: "token_id" }, { name: "owner_of" }] }]
  )

enum StatsType {
  users
  listings
  sales
  bids
  offers
  trades
  blindBids
  blindOffers
  blindTrades
}

type Stats @entity {
  id: ID! #"{StatsType}_stats"
  type: StatsType!
  count: BigInt!
}

type User @entity {
  id: ID! #address
  createdAt: String!
  marketItems: [MarketItem!] @derivedFrom(field: "user")
  swaps: [Swap!] @derivedFrom(field: "buyer")
  bids: [Bid!] @derivedFrom(field: "bidder")
  offers: [Offer!] @derivedFrom(field: "offerer")
  trades: [Trade!] @derivedFrom(field: "trader")
  rewards: [RewardsUser!] @derivedFrom(field: "user")
  mints: [Mint!] @derivedFrom(field: "minter")
}

type MarketItem @entity {
  id: ID! #fromAddress + tokenAddress + itemId
  active: Boolean!
  user: User!
  nft: NFT!
  itemId: BigInt
  amount1155: BigInt
  price: BigInt
  swaps: [Swap!] @derivedFrom(field: "item")
  bids: [Bid!] @derivedFrom(field: "item")
  offers: [Offer!] @derivedFrom(field: "item")
  trades: [Trade!] @derivedFrom(field: "item")
}

enum NFTType {
  ERC721
  ERC1155
}

type Metadata @entity {
  id: ID! #token_address + token_id
  nft: NFT!
  type: NFTType!
  uri: String
  name: String
  symbol: String
}

type NFT @entity {
  id: ID! #token_address + token_id
  contract_type: Bytes!
  token_address: Bytes!
  token_id: BigInt!
  owner_of: Bytes!
  metadata: Metadata! @derivedFrom(field: "nft")
  marketItems: [MarketItem!] @derivedFrom(field: "nft")
}

type Collection @entity {
  id: ID! #address
  address: Bytes!
  name: Bytes!
  canTrade: Boolean!
}

enum OrderType {
  listed
  blind
  tradeItem
}

type Token @entity {
  id: ID! # address
  token_address: Bytes!
  name: String!
  symbol: String!
  decimals: BigInt!
}

type Swap @entity {
  id: ID! # tx
  date: String!
  type: OrderType!
  item: MarketItem!
  buyer: User!
  value: BigInt!
  amount1155: BigInt!
}

type Mint @entity {
  id: ID! # tx
  date: String!
  minter: User!
  nftIds: BigInt!
  value: BigInt
  redemptionToken: Token
}

type Offer @entity {
  id: ID! # tx
  type: OrderType!
  date: String!
  item: MarketItem!
  offerId : BigInt!
  offerer: User!
  isSpecific: Boolean! # bool
  token: Token!
  amount: BigInt!
  valid: Boolean!
}

type Bid @entity {
  id: ID! # tx
  type: OrderType!
  date: String!
  item: MarketItem!
  bidId : BigInt!
  bidder: User!
  value: BigInt!
  user: Bytes! #address
  isSpecific: Boolean! # bool
  valid: Boolean!
}

type Trade @entity {
  id: ID! # tx
  type: OrderType!
  date: String!
  item: MarketItem!
  tradeId : BigInt!
  trader: User!
  isSpecific: Boolean! # bool
  valid: Boolean!
}

enum RewardType {
  dao
  dev
  user
  pham
}

type RewardsToken @entity {
  id: ID! #token_address
  token: Token!
  amount: BigInt!
}

type ClaimedRewards @entity {
  id: ID! # tx
  user: RewardsUser!
  date: String!
  type: RewardType!
  eth: BigInt!
  tokens: [RewardsToken!]
}

type RewardsUser @entity {
  id: ID! #address
  user: User!
  count: BigInt!
  type: RewardType!
  createdAt: String!
  claims: [ClaimedRewards!] @derivedFrom(field: "user")
  alpha: BigInt
  delta: BigInt
  omega: BigInt
}

type ClaimClock @entity {
  id: ID! #event.block.timestamp
  date: String!
  alpha: BigInt!
  delta: BigInt!
  omega: BigInt!
  totalUsers: BigInt!
  totalDevs: BigInt!
  totalEther: BigInt!
  tokens: [RewardsToken!]
}

enum ReceivedRewardsType {
  eth
  tokens
}

type ReceivedRewards @entity {
  id: ID!
  date: String!
  type: ReceivedRewardsType!
  value: BigInt
  amount: BigInt
  token: RewardsToken
}
